Functions.ErrorIO.swift
	public func coalesce
    <T, E: NSError>
    (arr: [Result<T, E>]) -> Result<[T], ErrorIO>
	public func coalesce2
    <T, U, E: NSError>
    (arr: [(Result<T, E>, Result<U, E>)]) -> Result<[(T, U)], ErrorIO>
	public func failure <T> (message: String, file: String = __FILE__, line: Int = __LINE__) -> Result<T, ErrorIO>
	public func failure <T> (nserror:NSError, file: String = __FILE__, line: Int = __LINE__) -> Result<T, ErrorIO>
	public func asResult <T, E> (error:E) -> Result<T, E>
Functions.Functional.swift
	public func mapRight1
    <T, U, V>
    (transform: U -> V) (_ tuple: (T, U)) -> (T, V)
	public func mapKeys
    <T, U, V>
    (transform: T -> V) (_ dict:[T: U]) -> [V: U]
	public func mapValues
    <T, U, V>
    (transform: U -> V) (_ dict:[T: U]) -> [T: V]
	public func makeLeft
    <T, U>
    (transform:T -> U) (_ value:T) -> (U, T)
	public func takeLeft
    <T, U>
    (tuple: (T, U)) -> T
	public func takeRight
    <T, U>
    (tuple: (T, U)) -> U
	public func takeWhileGenerator <S: SequenceType>
    (seq: S, predicate:S.Generator.Element -> Bool) -> AnyGenerator<S.Generator.Element>
	public func takeGenerator <S: SequenceType>
    (seq: S, n: Int) -> AnyGenerator<S.Generator.Element>
	public func groupBy
    <K: Hashable, V, S: SequenceType where S.Generator.Element == V>
    (keyClosure:V -> K) (_ seq:S) -> [K: [V]]
	public func countWhere <S: SequenceType>
    (predicate: S.Generator.Element -> Bool) (_ seq: S) -> Int
	public func mapIfIndex
    <S: SequenceType, D: RangeReplaceableCollectionType where S.Generator.Element == D.Generator.Element>
    (source: S, transform: S.Generator.Element -> S.Generator.Element, ifIndex: Int -> Bool) -> D
	public func mapEveryNth
    <S: SequenceType, C: RangeReplaceableCollectionType where S.Generator.Element == C.Generator.Element>
    (source: S, n: Int, transform: S.Generator.Element -> S.Generator.Element) -> C
Functions.Math.swift
	public func sum <S: SequenceType where S.Generator.Element: IntegerType>
    (nums: S) -> S.Generator.Element
Operators.ErrorIO.swift
	public func <~ (lhs:ErrorIO, rhs:NSError) -> ErrorIO
	public func <~ (lhs:ErrorIO, rhs:String) -> ErrorIO
	public func <~ (lhs:ErrorIO, rhs:ErrorIO) -> ErrorIO
Functions.Result.swift
	public func selectFailures
    <T, E>
    (array: [Result<T, E>]) -> [E]
	public func rejectFailures <T, E>
    (source: [Result<T, E>]) -> [T]
	public func rejectFailuresAndDispose <T, E>
    (disposal:E -> Void) (source: [Result<T, E>]) -> [T]
ErrorIO.swift
	public struct Constants
	public static let FileKey = "__file__"
	public static let LineKey = "__line__"
	public var hasErrors: Bool { return errors.count > 0 }
	public var localizedDescription: String
	public init()
	convenience required public init(arrayLiteral errors: Element...)
	public class func defaultError(userInfo: [NSObject: AnyObject]) -> ErrorIO
	public class func defaultError(message message: String, file: String = __FILE__, line: Int = __LINE__) -> ErrorIO
	public class func defaultError(file: String = __FILE__, line: Int = __LINE__) -> ErrorIO
	required public init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") }
	public func asResult <T> () -> Result<T, ErrorIO>
	public func generate() -> AnyGenerator<Element>
	public var startIndex : Index { return errors.startIndex }
	public var endIndex   : Index { return errors.endIndex }
	public func reserveCapacity(n: Index.Distance)
Result.swift
	public func success<T, E:ErrorType> (value: T) -> Result<T,E>
	public let ErrorLineKey = "LMErrorLine"
	public func failure<T>(message: String, file: String = __FILE__, line: Int = __LINE__) -> Result<T,NSError>
	public func failure<T,E>(error: E) -> Result<T,E>
	public func `try`(f: (NSErrorPointer -> Bool), file: String = __FILE__, line: Int = __LINE__) -> Result<(),NSError>
	case Success(Box<T>)
	case Failure(Box<E>)
	public var isSuccess: Bool
	public var description: String
	public func ??<T,E>(result: Result<T,E>, @autoclosure defaultValue:  () -> T) -> T
	public func ==<T, E where T: Equatable, E: Equatable>(lhs: Result<T, E>, rhs: Result<T, E>) -> Bool
	public func !=<T, E where T: Equatable, E: Equatable>(lhs: Result<T, E>, rhs: Result<T, E>) -> Bool
	public let unbox: T
	public init(_ value: T) { self.unbox = value }
Functions.Strings.swift
	public func safeText <T> (opt:Optional<T>) -> String
	public func padx (length:Int) (string:String) -> String
	public enum Error: ErrorType
	case Problem(msg: String)
	public func trimToLength (string:String, length:Int) -> String
Operators.fmap.swift
	public func <^>
    <A, B>
    (f: A -> B, maybeValue: A?) -> B?
	public func <^>
    <A, B>
    (f: A -> B, values: [A]) -> [B]
	public func <^>
    <A, B, E>
    (f: A -> B, values: Result<A, E>) -> Result<B, E>
Operators.bind.swift
	public func >>-
    <A, B> (maybeValue: A?, f: A -> B?) -> B?
	public func >>-
    <A, B> (wrapped: [A], f: A -> [B]) -> [B]
	public func >>-
    <A, B, E>
    (maybeValue: Result<A, E>, f: A -> Result<B, E>) -> Result<B, E>
	public func >>- <E>
    (maybeValue: Result<(), E>, f: () -> Result<(), E>) -> Result<(), E>
	public func >>- <E>
    (maybeValue: Result<Bool, E>, f: () -> Result<Bool, E>) -> Result<Bool, E>
	public func -<< <A, B, E> (f:A -> Result<B, E>, maybeValue:Result<A, E>) -> Result<B, E>
Operators.apply.swift
	public func <*>
    <A, B>
    (f: (A -> B)?, maybeValue: A?) -> B?
	public func <*>
    <A, B, E: ErrorType>
    (f: Result<A -> B, E>, values: Result<A, E>) -> Result<B, E>
Operators.Misc.swift
	public func =?? <T>(inout lhs:T, maybeRhs: T?)
	public func =?? <T>(inout lhs:T?, maybeRhs: T?)
	public func =?? <T, E: ErrorType> (inout lhs:T, result: Result<T, E>)
	public func =?? <T, E: ErrorType> (inout lhs:T?, result: Result<T, E>)
	public func ??= <T: Any> (inout lhs:T?, @autoclosure rhs: () -> T)
	public func ??= <T: Any> (inout lhs:T?, @autoclosure rhs: () -> T?)
	public func ?± <T, E: ErrorType>
	public func ?± <T, E: ErrorType>
    (lhs: Result<T, E>, @autoclosure rhs: () -> Result<T, E>) -> Result<T, E>
	public postfix func ‡
    <T, U, R>
    (f: (T, U) -> R) -> U -> T -> R
	<T, U, R>
Operators.pipe.swift
	<T, U>
	<T, U>
	public func <|
    <T, U>
    (f: (T -> U)?, t: T)
    -> U?
	public func <|
    <T, U, E>
    (f: Result<T -> U, E>, t: T)
    -> Result<U, E>
Operators.compose.swift
	public func >>> <T, U, V> (f: T -> U, g: U -> V) -> T -> V
	public func >>> <T, U, V, W> (f: (T, U) -> V, g: V -> W) -> (T, U) -> W
	public func >>> <T, U, V, W> (f: T -> U, g: (U, V) -> W) -> (T, V) -> W
	public func />>
    <T, U, V, E>
    (f: T -> Result<U, E>, g: U -> Result<V, E>)
    -> T -> Result<V, E>
	public func />>
    <T, U, V, E>
    (f: T -> Result<U, E>, g: Result<U, E> -> V)
    -> T -> V
	public func />>
    <T, U, V, E: ErrorType>
    (f: T -> Result<U, E>, g: U -> V)
    -> T -> Result<V, E>
	public func >>>
    <T, U>
    (f: T -> U, g: U -> Void)
    -> T -> Void
	public func |>>
    <T, U, E>
    (f: T -> Result<U, E>, g: Result<U, E> -> Void)
    -> T -> Void
	<T, U, V>
