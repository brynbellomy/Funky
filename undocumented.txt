Operators.fmap.swift
	public func <^>
    <A, B>
    (f: A -> B, maybeValue: A?)
    -> B?
	public func <^>
    <A, B>
    (f: A -> B, values: [A])
    -> [B]
	public func <^>
    <A, B>
    (f: A -> B, values: Result<A>)
    -> Result<B>
Functions.Math.swift
	public func sum
    <S: SequenceType where S.Generator.Element: IntegerType>
    (nums: S) -> S.Generator.Element
Operators.bind.swift
	public func >>-
    <A, B>
    (maybeValue: A?, f: A -> B?)
    -> B?
	public func >>-
    <A, B>
    (wrapped: [A], f: A -> [B])
    -> [B]
	public func >>-
    <A, B>
    (maybeValue: Result<A>, f: A -> Result<B>)
    -> Result<B>
	public func >>-
    <E>
    (maybeValue: Result<()>, f: () -> Result<()>)
    -> Result<()>
	public func >>-
    <E>
    (maybeValue: Result<Bool>, f: () -> Result<Bool>)
    -> Result<Bool>
	public func -<< <A, B> (f:A -> Result<B>, maybeValue:Result<A>) -> Result<B>
Regex.swift
	public class Regex: NSObject, BooleanType
	public private(set) var target: NSString
	public private(set) var regex:  NSRegularExpression
	public init(target t:NSString, pattern:String, options:NSRegularExpressionOptions = nil)
	public final var targetRange: NSRange
	public final func substring(range: NSRange) -> NSString!
	public func doesMatch(options: NSMatchingOptions = nil) -> Bool
	public func range(options: NSMatchingOptions = nil) -> NSRange
	public func match(options: NSMatchingOptions = nil) -> String!
	public func groups(options: NSMatchingOptions = nil) -> [String]!
	public func groupsForMatch(match: NSTextCheckingResult!) -> [String]!
	public func matchResults(options: NSMatchingOptions = nil) -> [NSTextCheckingResult]
	public func ranges(options: NSMatchingOptions = nil) -> [NSRange]
	public func matches(options: NSMatchingOptions = nil) -> [String]
	public func allGroups(options: NSMatchingOptions = nil) -> [[String]]
	public func dictionary(options: NSMatchingOptions = nil) -> [String: String]
	public func substituteMatches(substitution: (NSTextCheckingResult, UnsafeMutablePointer<ObjCBool>) -> String,
                                       options:  NSMatchingOptions = nil)
        -> NSMutableString
	public var boolValue: Bool
	public func RegexMutable(string: NSString) -> NSMutableString
	public func ~= (left: Regex, right:String) -> NSMutableString
	public func ~= (left: Regex, right: [String]) -> NSMutableString
	public func ~= (left: Regex, right: (String) -> String) -> NSMutableString
	public func ~= (left: Regex, right: ([String]) -> String) -> NSMutableString
NSString.h
	class NSString : NSObject, NSCopying, NSMutableCopying, NSSecureCoding, NSCoding
	class NSString : NSObject, NSCopying, NSMutableCopying, NSSecureCoding, NSCoding
Operators.apply.swift
	public func <*>
    <A, B>
    (f: (A -> B)?, maybeValue: A?)
    -> B?
	public func <*>
    <A, B>
    (f: Result<A -> B>, values: Result<A>)
    -> Result<B>
Operators.Misc.swift
	public func ?Â± <T> (lhs: Result<T>, rhs: @autoclosure () -> Result<T>) -> Result<T>
	<T, U, R>
    (f: (T, U) -> R) -> U -> T -> R {
        retu
Operators.ErrorIO.swift
	public func <~ (var lhs:ErrorIO, rhs:NSError) -> ErrorIO
	public func <~ (var lhs:ErrorIO, rhs:ErrorIO) -> ErrorIO
Operators.pipe.swift
	public func <|
    <T, U>
    (f: (T -> U)?, t: T)
    -> U?
	public func <|
    <T, U>
    (f: Result<T -> U>, t: T)
    -> Result<U>
NSError.h
	class NSError : NSObject, NSCopying, NSSecureCoding, NSCoding
NSError+Coalescing.swift
	public class func multiError(errors:[NSError]) -> NSError
	public var errorIO:      ErrorIO?
	public class func coalesce(errors:[NSError]) -> NSError
ErrorIO.swift
	func formatError(error:NSError) -> String
	public struct Constants
	public static let FileKey = "__file__"
	public static let LineKey = "__line__"
	public class var defaultDomain: String
	public class var defaultCode:   Int
	public private(set) var errors = UnderlyingCollection()
	override public var localizedDescription: String
	required public init()
	convenience public init(flatten others: ErrorIO...)
	convenience public init(with others: NSError...)
	public init(arrayLiteral errors: Element...)
	public class func defaultError(userInfo: [NSObject: AnyObject]) -> ErrorIO
	public class func defaultError(message: String, file: String = __FILE__, line: Int = __LINE__) -> ErrorIO
	public class func defaultError(file: String = __FILE__, line: Int = __LINE__) -> ErrorIO
	required public init(coder aDecoder: NSCoder)
	public func generate() -> Generator
	public var startIndex : Index
	public var endIndex   : Index
	public func reserveCapacity(n: Index.Distance)
Functions.ErrorIO.swift
	public func coalesce <T> (arr:[Result<T>]) -> Result<[T]>
	public func coalesce2 <T, U> (arr:[(Result<T>, Result<U>)]) -> Result<[(T, U)]>
	public func failure <T> (message: String, file: String = __FILE__, line: Int = __LINE__) -> Result<T>
Functions.Functional.swift
	public func both <T, U>
    (one:T?, two:U?) -> (T, U)?
	public func any <S: SequenceType>
    (predicate: S.Generator.Element -> Bool) (seq: S) -> Bool
	public func all <S: SequenceType>
    (predicate: S.Generator.Element -> Bool) (seq: S) -> Bool
	public func all
    <T, U, V>
    (one:T?, two:U?, three:V?) -> (T, U, V)?
	public func all
    <T, U, V, W>
    (one:T?, two:U?, three:V?, four:W?) -> (T, U, V, W)?
	public func zipseq
    <S: SequenceType, T: SequenceType>
    (one:S, two:T) -> SequenceOf<(S.Generator.Element, T.Generator.Element)>
	public func unfold <T, U> (closure: T -> (U, T)?) (initial:T) -> SequenceOf<U>
	public func partition
    <S: SequenceType, T where T == S.Generator.Element>
    (predicate:T -> Bool) (seq:S) -> ([T], [T])
	public func mapRight1 <T, U, V> (transform:U -> V) (tuple:(T, U)) -> (T, V)
	public func mapRight <T, U, V> (transform: U -> V) (seq:[T: U]) -> [(T, V)]
	public func mapKeys <T, U, V> (transform: T -> V) (dict:[T: U]) -> [V: U]
	public func mapValues <T, U, V> (transform: U -> V) (seq:[T: U]) -> [T: V]
	public func makeLeft <T, U> (transform:T -> U) (value:T) -> (U, T)
	public func makeRight <T, U> (transform:T -> U) (value:T) -> (T, U)
	public func takeLeft <T, U> (tuple:(T, U)) -> T
	public func takeRight <T, U> (tuple:(T, U)) -> U
	public func takeFirst <S: SequenceType> (predicate: S.Generator.Element -> Bool) (seq:S) -> S.Generator.Element?
	public func takeWhile
    <S: SequenceType>
    (predicate: S.Generator.Element -> Bool) (seq: S) -> [S.Generator.Element]
	public func selectFailures <T> (array:[Result<T>]) -> [NSError]
	public func rejectFailures <T> (source: [Result<T>]) -> [T]
	public func rejectFailuresAndDispose <T> (disposal:NSError -> Void) (source: [Result<T>]) -> [T]
	public func groupBy
    <K: Hashable, V, S: SequenceType where S.Generator.Element == V>
    (keyClosure:V -> K) (seq:S) -> [K: [V]]
	public func pairs <K: Hashable, V> (dict:[K: V]) -> [(K, V)]
	public func mapIfIndex
    <S: SequenceType, C: ExtensibleCollectionType where S.Generator.Element == C.Generator.Element>
    (source: S, transform: (S.Generator.Element) -> S.Generator.Element, ifIndex: Int -> Bool)
        -> C
	public func mapEveryNth
    < S: SequenceType, C: ExtensibleCollectionType
      where S.Generator.Element == C.Generator.Element >
    (source: S, n: Int, transform: S.Generator.Element -> C.Generator.Element)
    -> C
Operators.compose.swift
	public func />> <T, U, V> (f: T -> Result<U>, g: U -> Result<V>) -> T -> Result<V>
	public func />> <T, U, V> (f: T -> Result<U>, g: Result<U> -> V) -> T -> V
	public func />> <T, U, V> (f: T -> Result<U>, g: U -> V) -> T -> Result<V>
	public func >>> <T, U> (f: T -> U, g: U -> Void) -> T -> Void
	public func |>> <T, U> (f: T -> Result<U>, g: Result<U> -> Void) -> T -> Void
Functions.Strings.swift
	func renderKeyValue(key:String, value:V) -> String { return "\(
	func toCGFloat() -> CGFloat? {
        return CGFlo
